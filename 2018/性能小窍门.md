# 性能小窍门
---
 [原文链接](https://developer.android.com/training/articles/perf-tips.html)

* [避免创建不必要的对象](#避免创建不必要的对象)
* [静态优于虚拟](#静态优于虚拟)
* [为常量使用satic,final](#为常量使用static final)
* [使用增强for](#使用加强循环语法)
* [考虑包级访问替代私有访问私有内部类](#考虑包级访问替代私有访问私有内部类)
* [避免使用浮点数](#避免使用浮点数)
* [了解并使用第三方库](#了解和使用第三方库)
* [谨慎使用本地代码](#谨慎使用本地方法)
* [性能神话](#性能神话)
* [持续估量](#持续估量)

此文档主要覆盖了一些细微的优化点,组合起来可以全面改善应用之性能,却并非会带来巨大的性能效果.
选择正确的算法和数据结构应该永远是你首选,却不是本文所涵盖的范围了. 平日里编码你应该应用此文
中的小窍门,这样你可以吸收并养成高效编码的习惯.

编写高效的代码有两条基本原则:

- 不做不必要之工作
- 不分配可以避免分配的内存

当细微地优化一款安卓应用,最不易处理的难题之一就是你的应用要运行在多种类型的硬件上.不同版本
的虚拟机以不同的速度运行在不同的处理器上.通常的情况不是"X设备是比Y设备快/慢的因素",并且引申
你的结论从一个设备到另外的设备.特别的,在模拟器上的考量,几乎无法得到任何设备的性能.设备是否
带有JIT也有巨大不同:在有JIT的设备上的最优代码,通常在不带有JIT的设备上不是这样.

为了确保你的应用性能通过大量设备,确保你的代码在所有级别上高效并且积极地优化你的性能.

### 避免创建不必要的对象

对象的创建用于都有代价的.具有针对临时对象的每个线程分配池的世代垃圾回收器可以使分配代价更
小,但是分配内存一直是比不分配内存要更加昂贵.

当你在应用中分配更多的对象,你将强制定期垃圾回收,造成用户体验的小顿挫.并发垃圾回收再Android
2.3帮助中有介绍,但是非必要的工作应该总是避免去做.

于是,你应该避免创建你不需要的对象.下面是一些可以帮你的示例:

* 如果你拥有一个返回一个字符串的方法,并且你知道该结果字符串无论如何会追加到一个`StringBuffer`
后面,修改你的方法签名和实现,让该方法可以直接追加,而不是创建短生命的临时对象.

* 当从一个输入数据集中获得数据时,尝试返回原串的子串,而不是创建原串的一个副本.你将创建一个新
的`String`对象,但是他会共享数据`char[]`.(需要权衡的是,如果你未来只使用原来输入串的一小部分,
如果你选择了这条路,你无论如何会一直保持该对象在内存中)

一个更加激进的想法是分割多维数组为平行的单个一维数组:

* `int`数组是比`Integer`数组要好的多的,但是这同样泛化为一个事实:两个平行的`int`数组,同样
比一个`(inti,int)`数组更加高效.此理可推广于任何原始类型.

* 如果你需要实现一个存储二元对象的容器`(Foo,Bar)`,尝试记得两个平行数组`Foo[]`和`Bar[]`
通常情况下是优于单个数组去访问对象的.(问题在于,当然,你的`API`是为了别人的代码访问而设计.在
那些情况下,通常一个小的对于速度的妥协,为了更好的`API`设计可以的.但是在你自己的内部代码,你
应该尽可能地尝试并且使之高效.)

### 静态优于虚拟

如果你不需要访问一个对象的字段,把你的方法写成静态的.调用大概会快15%-20%.这也是一个最佳实践,
因为你可以从方法签名告诉,这个方法不能改变对象的状态.

### 为常量使用static final

考虑下面类顶部的声明:

```java
static int intVal = 42;
static String strVal = "Hello, world!";
```

编译器生成一个类初始化方法叫做`<clinit>`,当类首次使用时执行.该方法存储值`42`到`intVal`,并且从类文件的字符串常量表中为`strVal`提取引用.当这些值稍后被引用,他们可以被找到的字段访问.

我们可以通过`final`来改进该问题:

```java
static final int intVal = 42;
static final String strVal = "Hello, world!";
```

这样,类不再请求`<vlinit>`方法,因为常量进入了`dex`文件的静态字段初始化器.代码引用`intVal`
将直接使用整数值`42`,并且访问`strVal`将直接低代价使用`string constant`指令,而不是寻找字段.

>注意:这个优化仅适用于原始类型和`String`常量,不是任意的引用类型.在任何可能使用`static final`的场景下声明常量仍然是良好的实践.

### 使用加强循环语法

加强`for`循环(以`for-each`闻名)可以用在实现了`Iterable`接口的集合和数组里.在集合中,一个迭代器是被分配去制造接口调用`hasNext()`和`next()`.在`ArrayList`,一个手写计数循环快3倍(无论是否拥有JIT),但是对别的集合,这个加强循环语法将完全等价于显式迭代器的使用.

有几种方法可以迭代一个数组:


```
static class Foo {
    int mSplat;
}

Foo[] mArray = ...

public void zero() {
    int sum = 0;
    for (int i = 0; i < mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}

public void one() {
    int sum = 0;
    Foo[] localArray = mArray;
    int len = localArray.length;

    for (int i = 0; i < len; ++i) {
        sum += localArray[i].mSplat;
    }
}

public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}

```

`zero()` 是最慢的,因为`JIT`还不能优化通过循环为每次迭代获取数组长度的代价.

`one()`会快一点.他把所有的东西放进本地变量里,避免寻找.只有数组长度性能受益.

`two()`是在没有`JIT`的设备上最快的.并且和在拥有`JIT`的设备上的`one()`是不可分别的.他使用了加强`for`循环的语法基于JDK5

因此,你默认就应该使用加强`for`循环,但是注意手写计数循环在`ArrayList`上的性能.

> Tip: 看Josh Bolch's << Effective Java >>, 第46条

### 考虑包级访问替代私有访问私有内部类

考虑下面的类定义:

```
public class Foo {
    private class Inner {
        void stuff() {
            Foo.this.doStuff(Foo.this.mValue);
        }
    }

    private int mValue;

    public void run() {
        Inner in = new Inner();
        mValue = 27;
        in.stuff();
    }

    private void doStuff(int value) {
        System.out.println("Value is " + value);
    }
}

```

重点是我们定义了一个私有内部类`Foo$Inner`,可以在外部类中直接访问私有方法和私有实例字段.这是合法的,并且代码如期望打印`Value is 27`.

问题是虚拟机意识到从`Foo$Inner`直接访问`Foo`的私有成员是非法的,因为`Foo`和`Foo$Inner`是不同的类,尽管`Java`语言语序一个内部类访问外部类的成员.为了弥补差距,编译器生成了几种合成方法:

```
/*package*/ static int Foo.access$100(Foo foo) {
    return foo.mValue;
}
/*package*/ static void Foo.access$200(Foo foo, int value) {
    foo.doStuff(value);
}
```

内部类代码访问这些静态方法,当他需要去访问外部类的`mValue`字段或者调用`doStuff()`方法.这意味着,上面的代码真的是很糟糕的一个示例,你通过访问方法区访问成员字段.早先我们谈论了访问者是如何比直接访问字段更慢的,所以这是一个语言的习惯用法,导致了性能中无形隐藏.

如果你正在像这样在性能危险区使用代码,你可以通过生命字段和方法让内部类拥有包访问权限来避免,而不是私有的访问.不幸的是,这意味着这些字段可以直接被同一个包中的其他类访问到,所以你不应该在公有`API`中使用.

### 避免使用浮点数

根据经验,在`Android`设备上,浮点数比整型慢2倍.

在速度方面,`float`和`double`在大多数现代硬件上没有区别.空间座标,`double`是2倍大.在桌面设备上,空间不是问题,你应该优先选择`double`而不是`float`.

同样,即便是整型,一些处理器有硬件乘法但是没有硬件除法.在这种情况下,整数除法和求余操作是在软件中完成的.考虑下你正在设计一个哈希表或者在做很多的数学操作.

### 了解和使用第三方库

除了常见的原因喜欢使用第三方库而不是自己手写,请记住,系统可以用手工编码的汇编程序替换对库方法的调用,这可能比`JIT`为等量的`java`生成的最好的代码还要好.典型的例子是`String.indexOf()`和相关的`API`,`Dalvik`用内联的内在取代了.相似的,`System.arraycopy()`方法在拥有`JIT`的`NexusOne`机器上比手写的循环快9倍.
> Tip: 见Josh Bloch 的 Effective Java, 第47条.

### 谨慎使用本地方法

使用`Android NDK`写本地代码不是比`java`语言编码更必需和更高效的.一件事,`java-native`转化的代价,`JIT`不能优化这些边界.如果你正在分配本地资源(本地堆内存,文件描述符或别的什么),这将是显著地困难去及时的回收这些资源.你同时需要为每个平台架构编译代码.你甚至不得不为同一个架构编译多个版本:本地代码编译后在`G1`的`ARM`处理器上不能完全发挥`Nexus One`上`ARM`的优势,同时,针对`Nexus One`上的`ARM`编译的代码不能再`G1`的`ARM`上运行.

当你有一个已经存在的本地代码库想要链接到`Android`上,本地代码是根本地用处,而不是`加速`你使用`java`语言编写的安卓应用部分.

如果你需要使用本地代码,是应该阅读我们的[JNITips](https://developer.android.com/training/articles/perf-jni.html).

>Tip: 见Josh Bloch 的 Effective Java, 第54条.

### 性能神话

在没有`JIT`的设备上,通过一个有确定类型的变量调用方法是比通过结果要更加高效的.(因此,比如,在`HashMap map`上调用方法比`Map map`上代价更低,尽管两个例子的`map`的类型都是`HashMap`.)这不是个慢2倍的例子,确切的不同是慢6%.此外,`JIT`使者二者相差无几.

在没有`JIT`的设备上,缓存访问字段比重复访问字段快20%.有`JIT`时,字段访问和本地访问代价一样,所以这不是重要的优化除非这让你感觉代码易读了.(相同还有`final`,`static`,和`static final`字段).

### 持续估量

当开始优化之前,确保你有一个待解决的问题.确保可以确切地衡量你已存在的性能,否则你不能测量尝试备选方案的好处.

你也许发现`Traceview`用来收集资料很有用,重要的是要意识到他目前禁用了`JIT`,这可能会导致他错误地分配`JIT`可能能够赢回的代码.在进行`TraceView`数据建议的更改之后,确保生成的代码在没有`TraceView`的情况下运行时运行速度更快,这一点尤其重要.

要想更好的帮助你收集和调试应用,看下面的文档:

* [Profiling with Traceview and dmtracedump](https://developer.android.com/tools/debugging/debugging-tracing.html)
* [Analyzing UI Performance with Systrace](https://developer.android.com/tools/debugging/systrace.html)
