# 性能小窍门
---
 [原文链接](https://developer.android.com/training/articles/perf-tips.html)

* [避免创建不必要的对象](#避免创建不必要的对象)
* [静态优于虚拟](#静态优于虚拟)
* [为常量使用satic final](#为常量使用static,final)
* [使用增强for](#使用加强循环语法)
* [考虑包级访问替代私有访问私有内部类](#考虑包级访问替代私有访问私有内部类)
* [避免使用浮点数](#避免使用浮点数)
* [了解并使用第三方库]()
* [谨慎使用本地代码]()
* [性能神话]()
* [持续估量]()

此文档主要覆盖了一些细微的优化点,组合起来可以全面改善应用之性能,却并非会带来巨大的性能效果.
选择正确的算法和数据结构应该永远是你首选,却不是本文所涵盖的范围了. 平日里编码你应该应用此文
中的小窍门,这样你可以吸收并养成高效编码的习惯.

编写高效的代码有两条基本原则:

- 不做不必要之工作
- 不分配可以避免分配的内存

当细微地优化一款安卓应用,最不易处理的难题之一就是你的应用要运行在多种类型的硬件上.不同版本
的虚拟机以不同的速度运行在不同的处理器上.通常的情况不是"X设备是比Y设备快/慢的因素",并且引申
你的结论从一个设备到另外的设备.特别的,在模拟器上的考量,几乎无法得到任何设备的性能.设备是否
带有JIT也有巨大不同:在有JIT的设备上的最优代码,通常在不带有JIT的设备上不是这样.

为了确保你的应用性能通过大量设备,确保你的代码在所有级别上高效并且积极地优化你的性能.

### 避免创建不必要的对象

对象的创建用于都有代价的.具有针对临时对象的每个线程分配池的世代垃圾回收器可以使分配代价更
小,但是分配内存一直是比不分配内存要更加昂贵.

当你在应用中分配更多的对象,你将强制定期垃圾回收,造成用户体验的小顿挫.并发垃圾回收再Android
2.3帮助中有介绍,但是非必要的工作应该总是避免去做.

于是,你应该避免创建你不需要的对象.下面是一些可以帮你的示例:

* 如果你拥有一个返回一个字符串的方法,并且你知道该结果字符串无论如何会追加到一个`StringBuffer`
后面,修改你的方法签名和实现,让该方法可以直接追加,而不是创建短生命的临时对象.

* 当从一个输入数据集中获得数据时,尝试返回原串的子串,而不是创建原串的一个副本.你将创建一个新
的`String`对象,但是他会共享数据`char[]`.(需要权衡的是,如果你未来只使用原来输入串的一小部分,
如果你选择了这条路,你无论如何会一直保持该对象在内存中)

一个更加激进的想法是分割多维数组为平行的单个一维数组:

* `int`数组是比`Integer`数组要好的多的,但是这同样泛化为一个事实:两个平行的`int`数组,同样
比一个`(inti,int)`数组更加高效.此理可推广于任何原始类型.

* 如果你需要实现一个存储二元对象的容器`(Foo,Bar)`,尝试记得两个平行数组`Foo[]`和`Bar[]`
通常情况下是优于单个数组去访问对象的.(问题在于,当然,你的`API`是为了别人的代码访问而设计.在
那些情况下,通常一个小的对于速度的妥协,为了更好的`API`设计可以的.但是在你自己的内部代码,你
应该尽可能地尝试并且使之高效.)

### 静态优于虚拟

如果你不需要访问一个对象的字段,把你的方法写成静态的.调用大概会快15%-20%.这也是一个最佳实践,
因为你可以从方法签名告诉,这个方法不能改变对象的状态.

### 为常量使用`static,final`

考虑下面类顶部的声明:

```java
static int intVal = 42;
static String strVal = "Hello, world!";
```

编译器生成一个类初始化方法叫做`<clinit>`,当类首次使用时执行.该方法存储值`42`到`intVal`,并且从类文件的字符串常量表中为`strVal`提取引用.当这些值稍后被引用,他们可以被找到的字段访问.

我们可以通过`final`来改进该问题:

```java
static final int intVal = 42;
static final String strVal = "Hello, world!";
```

这样,类不再请求`<vlinit>`方法,因为常量进入了`dex`文件的静态字段初始化器.代码引用`intVal`
将直接使用整数值`42`,并且访问`strVal`将直接低代价使用`string constant`指令,而不是寻找字段.

>注意:这个优化仅适用于原始类型和`String`常量,不是任意的引用类型.在任何可能使用`static final`的场景下声明常量仍然是良好的实践.

### 使用加强循环语法

加强`for`循环(以`for-each`闻名)可以用在实现了`Iterable`接口的集合和数组里.在集合中,一个迭代器是被分配去制造接口调用`hasNext()`和`next()`.在`ArrayList`,一个手写计数循环快3倍(无论是否拥有JIT),但是对别的集合,这个加强循环语法将完全等价于显式迭代器的使用.

有几种方法可以迭代一个数组:


```
static class Foo {
    int mSplat;
}

Foo[] mArray = ...

public void zero() {
    int sum = 0;
    for (int i = 0; i < mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}

public void one() {
    int sum = 0;
    Foo[] localArray = mArray;
    int len = localArray.length;

    for (int i = 0; i < len; ++i) {
        sum += localArray[i].mSplat;
    }
}

public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}

```

`zero()` 是最慢的,因为`JIT`还不能优化通过循环为每次迭代获取数组长度的代价.

`one()`会快一点.他把所有的东西放进本地变量里,避免寻找.只有数组长度性能受益.

`two()`是在没有`JIT`的设备上最快的.并且和在拥有`JIT`的设备上的`one()`是不可分别的.他使用了加强`for`循环的语法基于JDK5

因此,你默认就应该使用加强`for`循环,但是注意手写计数循环在`ArrayList`上的性能.

> Tip: 看Josh Bolch's << Effective Java >>, 第46条

### 考虑包级访问替代私有访问私有内部类

考虑下面的类定义:

```
public class Foo {
    private class Inner {
        void stuff() {
            Foo.this.doStuff(Foo.this.mValue);
        }
    }

    private int mValue;

    public void run() {
        Inner in = new Inner();
        mValue = 27;
        in.stuff();
    }

    private void doStuff(int value) {
        System.out.println("Value is " + value);
    }
}

```

重点是我们定义了一个私有内部类`Foo$Inner`,可以在外部类中直接访问私有方法和私有实例字段.这是合法的,并且代码如期望打印`Value is 27`.

问题是虚拟机意识到从`Foo$Inner`直接访问`Foo`的私有成员是非法的,因为`Foo`和`Foo$Inner`是不同的类,尽管`Java`语言语序一个内部类访问外部类的成员.为了弥补差距,编译器生成了几种合成方法:

```
/*package*/ static int Foo.access$100(Foo foo) {
    return foo.mValue;
}
/*package*/ static void Foo.access$200(Foo foo, int value) {
    foo.doStuff(value);
}
```

内部类代码访问这些静态方法,当他需要去访问外部类的`mValue`字段或者调用`doStuff()`方法.这意味着,上面的代码真的是很糟糕的一个示例,你通过访问方法区访问成员字段.早先我们谈论了访问者是如何比直接访问字段更慢的,所以这是一个语言的习惯用法,导致了性能中无形隐藏.

如果你正在像这样在性能危险区使用代码,你可以通过生命字段和方法让内部类拥有包访问权限来避免,而不是私有的访问.不幸的是,这意味着这些字段可以直接被同一个包中的其他类访问到,所以你不应该在公有`API`中使用.

### 避免使用浮点数
