# `Android`内存管理概述
---
[原文链接](https://developer.android.com/topic/performance/memory-overview.html)

* [Garbage collection](#Garbage-collection)
* [Sharing Memory](#Sharing-Memory)
* [Allocating and Reclaiming App Memory](#Allocating-and-Reclaiming-App-Memory)
* [Restricting App Memory](#Restricting-App-Memory)
* [Switching apps](#Switching-apps)

`ART`和`Dalvik`虚拟机使用分页和[内存映射](https://github.com/xusx1024/android-weekly-cn/blob/master/2018/内存映射文件.md)管理内存.这意味着应用程序修改的任何内存(无论是通过分配新对象还是接触映射的页)仍然驻留在`RAM`中,并且无法被换出内存.从一个应用释放内存的唯一途径是释放应用持有的对象引用,使得内存被垃圾收集器可用.这样有一个例外:任何文件被无修改的映射,比如代码,如果系统需要在别的地方使用内存,可用被换出内存.

该页面解释了`Android`管理应用进程和内存的分配.查看更多关于如何更加高效管理内存的信息:[管理你应用的内存](https://github.com/xusx1024/android-weekly-cn/blob/master/2018/管理你应用的内存.md)

### Garbage collection

`垃圾收集器`

一个托管的内存环境,比如在`ART`或者`Dalvik`虚拟机中,持续追踪每次内存分配.一旦他决定一段内存不再被程序使用,他就释放其回到堆中,不需要程序员干涉.这个在托管的内存环境中关于重新申请不再使用的内存的机制就是著名的垃圾收集器.垃圾收集器有两个目标:找到程序中不再被访问的数据对象;重新分布被这些对象占用的资源.

`Android`的堆内存是分代的,也就是说根据分配的对象期望的生命时间和对象的大小,垃圾收集器追踪不同的桶.比如说,最近分配的对象在新生代,当对象在内存中待得时间足够长,就被提升到老年代,然后是永久代.

每一个年代的堆,都有其对象分配内存的专有的上限.任何时间一个年代将要填充满,系统就打算通过执行垃圾收集事件来释放内存.垃圾收集持续的时间取决于要收集的对象所处的年代以及每个年代有多少活动的对象.

尽管垃圾收集器可以非常快,但仍然可以影响你应用的性能.你通常不需要控制发生在你代码中的垃圾收集事件.系统有自己的标准(可达性分析?)来决定何时执行垃圾收集.当标准合适了,系统将停止进程并且开始垃圾回收.如果垃圾回收发生在敏感进程循环之中,比如动画或者音乐后台播放,这将增加执行时间.这种增长,会潜在增加代码执行时间,导致超过了推荐的流畅渲染框架的16毫秒阈值.

另外,你的代码流可能执行各样的工作,迫使垃圾收集器事件更多的执行或者使执行时间长于平时.比如说,如果你再一个渐变渲染动画的每一帧的循环中分配了多个对象,这么多对象也许会污染你的堆内存.在这种环境下,垃圾收集器执行多次垃圾收集事件并且降低了你的应用的性能.

更多关于垃圾收集器的信息,看wiki:[Garbage collection](https://en.wikipedia.org/wiki/Garbage_collection_(computer_science))

此处建议阅读`深入理解Java虚拟机:JVM高级特性与最佳实践`的`第三章:垃圾收集器与内存分配策略`了解垃圾收集器的标准以及常见的垃圾回收算法策略.

如果对虚拟机的内存分类不太了解,可以阅读`第二章:java内存区域与内存溢出异常`,了解`JVM`的一个进程的运行时数据区的各部分组成,并且熟悉各个部分的作用.

### Sharing Memory

`共享内存`

`Android`为了适应他在`RAM`中所需要的一切,尝试在进程间共享`RAM`页.有下面几种实现方式:

* 每个应用进程是从一个已经存在的叫做`Zygote`的进程中复刻的.`Zygote`进程当系统启动时开启,并且加载通用框架代码和资源(比如`Activity`主题).要开启一个新的应用进程,系统复刻`Zygote`进程,然后在新的进程中加载应用的代码.这种方式允许大多数`RAM`页面为框架代码和资源进行跨进程共享分配.

* 大多数静态数据是内存映射进入进程的.这项技术允许数据在进程间共享,并且也允许在需要时换出.静态数据的例子包括:`Dalvik`代码(通过将其放置在一个预链接的`odex`文件中进行直接映射),应用资源(通过设计资源表成为可以被映射的结构并对齐`APK`的`zip`条目.),还有传统项目元素比如在`.so`文件中的本地代码.

* 在很多方面,`Android`使用显式分配共享内存区域在进程间共享相同的动态`RAM`(通过`ashmen`或者`gralloc`(Graphics Alloc(图形分配))).比如,窗口`surface`使用应用程序和平门合成器之间的共享内存,还有内容提供者和访问者之间的共享内存.

由于大量使用共享内存,需要确定应用使用多少内存.确定应用内存使用量的相关内容请看:[调查RAM使用情况](https://github.com/xusx1024/android-weekly-cn/blob/master/2018/调查RAM使用情况.md)

### Allocating and Reclaiming App Memory

`分配和回收应用内存`

`Dalvik`对被限制在每个应用进程的单个虚拟内存范围之内.这个定义好的逻辑堆大小,可以根据需要增长,但是最大只能到系统为每个应用限制的大小.

逻辑堆的大小和堆实际使用的物理内存大小不同.当检测你的应用堆时,`Android`计算一个值叫做`按比例分配占用内存(PSS)`,无论脏和干净的页面的这个值都可以和别的进程共享-但是这个值会按照有多少应用共享了这块内存来按比例算出均摊部分(作为`PSS`).`PSS`是系统认定的你占用的物理内存大小.要查看更多关于`PSS`的信息,请看:[调查RAM使用情况](https://github.com/xusx1024/android-weekly-cn/blob/master/2018/调查RAM使用情况.md)

`Dalvik`堆没有压缩逻辑堆的大小,也就是`Android`并没有整理堆内存去关闭空间.`Android`能做的是,当堆的尾部没有可用空间时,压缩逻辑堆大小.然而,系统仍然可以减少堆使用的物理内存.在垃圾回收之后,`Dalvik`遍历堆并且发现未使用的页,然后使用`madvise`把这些页返回到内核.因此,成对的分配和回收大量的大块内存,会导致回收所有的已使用物理内存.然而,从小的分配中重新回收内存,也许没什么作用,因为这些为小资源而分配的页也许仍然在被一些对象分享,还未释放.

### Restricting App Memory

`限制应用内存`

为了保持多任务的环境,`Android`为每个应用设置了严格的堆大小限制.确切的堆大小限制根据设备有多少内存总量而有所不同.如果你的应用达到了堆容量的上限还要尝试分配更多内存,会导致`OOM`错误.

在某些情况下,你也许想要查询在当前设备上,系统还有多少堆空间可用.比如,确定多少数据可用安全的保留在缓存中.你可以通过`getMemoryClass()`向系统查询.这个方法返回一个`MB`为单位的整型值.

### Switching apps

`切换应用`

当用户在应用之间切换,`Android`保持不在前台的应用在`LRU`缓存中.不在前台的意思是,用户不可见或者运行着一个前台的服务比如音乐播放器.比如,用户开启第一个应用,一个进程创建,当用户离开这个应用,进程不会退出,系统会把进程保持在缓存中,如果用户待会儿返回应用,系统会重新启用该进程,因此应用之间切换会很快.

假如你的应用有一个缓存的进程,并且他保留了当前不需要的内存,然后你的应用-尽管用户没在使用他-仍然影响系统的整体性能.由于系统运行在低内存下,他会杀掉`LRU`缓存中的最近最少使用的进程.系统也会记录占用很大内存的进程并且终结他们释放`RAM`.

> 注意:当系统开始杀死`LRU`缓存中的进程,他主要是自上而下的工作.系统会估量哪个进程消耗更多内存,并且如果死亡会为系统提供更多的内存增益.你留在`LRU`中消耗的内存越少,对你的应用保留在`LRU`列表中越有利,并且可以更快地启动.

查看更多关于进程缓存的信息,以及`Android`设备里应用如何被杀死,看[Processes and Threads](https://developer.android.com/guide/components/processes-and-threads.html)的引导.
